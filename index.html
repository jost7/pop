<!DOCTYPE html>
<html>

<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4821590486014150"
     crossorigin="anonymous"></script>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="icons/iconsicon-192x192.png" />

    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            margin-bottom: 20px;
            padding-top: env(safe-area-inset-top);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-bottom: env(safe-area-inset-bottom);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none; /* Prevents scrolling */
            user-select: none; /* Prevents text selection */
            font-family: 'Press Start 2P', cursive;
            background: rgb(2, 0, 36);
            background: linear-gradient(0deg, rgba(2, 0, 36, 1) 0%, rgba(0, 212, 255, 1) 0%, rgba(52, 146, 255, 1) 100%);
        }

        #gameCanvas {
            max-height: calc(100vh - 60px); /* 60px leaves room for the ad banner */
            width: auto; /* Maintain aspect ratio */
            border: 3px solid black;
        }

        #ad-container {
            width: 100%;
            height: 50px; /* Adjust based on your ad size */
            margin-top: 0px; /* Space between canvas and ad */
            background-color: #ddd; /* Placeholder style */
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        canvas {
            touch-action: none; /* Prevents the browser's default touch behaviors */
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ad-container">
        <!-- Ad content goes here -->
        <p>Ad Banner</p>    
        <script>

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 370;
        canvas.height = 600;

        let gameStarted = false;

        let menuBalloons = [];

        // Call this when your page loads or your script starts
// drawMainMenu();

        function drawMainMenu() {
            // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw a semi-transparent overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Adjust color and transparency as needed
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    updateMenuBalloons();
    menuBalloons.forEach(drawBalloon); // Draw the balloons

    // // Create a linear gradient for the button background
    // let gradient = ctx.createLinearGradient(playButton.x, playButton.y, playButton.x, playButton.y + playButton.height);
    // gradient.addColorStop(0, '#28a745'); // Light green
    // gradient.addColorStop(1, '#155d27'); // Dark green

    // // Draw rounded button background
    // ctx.beginPath();
    // ctx.moveTo(playButton.x + playButton.radius, playButton.y);
    // ctx.arcTo(playButton.x + playButton.width, playButton.y, playButton.x + playButton.width, playButton.y + playButton.height, playButton.radius);
    // ctx.arcTo(playButton.x + playButton.width, playButton.y + playButton.height, playButton.x, playButton.y + playButton.height, playButton.radius);
    // ctx.arcTo(playButton.x, playButton.y + playButton.height, playButton.x, playButton.y, playButton.radius);
    // ctx.arcTo(playButton.x, playButton.y, playButton.x + playButton.width, playButton.y, playButton.radius);
    // ctx.closePath();
    // ctx.fillStyle = gradient;
    // ctx.fill();

    // // Add shadow for 3D effect
    // ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
    // ctx.shadowBlur = 4;
    // ctx.shadowOffsetX = 0;
    // ctx.shadowOffsetY = 4;
    // ctx.fill();

    // // Reset shadow for other elements
    // ctx.shadowColor = 'transparent';

    // // Button Text
    // ctx.fillStyle = 'white'; // Text color
    // ctx.font = '20px "Press Start 2P"'; // Font size and family
    // ctx.textAlign = 'center';
    // ctx.textBaseline = 'middle';
    // ctx.fillText('PLAY', playButton.x + playButton.width / 2, playButton.y + playButton.height / 2);

    //     // Draw the "How to Play" button
    //     drawButton(howToPlayButton, 'How to Play');

    // In drawMainMenu:
drawButton(playButton, 'PLAY');
// drawButton(howToPlayButton, 'How to Play');
// drawDebugRect(howToPlayButton);

    // Draw instructions text
    drawInstructions();

// After drawing the "PLAY" button
ctx.textAlign = 'left';
        // Request to draw the main menu again
        if (!gameStarted) {
        requestAnimationFrame(drawMainMenu);
    }
}

function wrapTextList(context, textList, x, startY, maxWidth, lineHeight) {
    let y = startY;

    for (let i = 0; i < textList.length; i++) {
        const words = textList[i].split(' ');
        let line = '';

        for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = context.measureText(testLine);
            const testWidth = metrics.width;

            if (testWidth > maxWidth && n > 0) {
                context.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            } else {
                line = testLine;
            }
        }

        context.fillText(line, x, y);
        y += lineHeight; // Move to the start of the next list item
    }
}

function drawInstructions() {
    let instructionsY = howToPlayButton.y + howToPlayButton.height + 20; // Start position for the instructions
    const maxWidth = canvas.width - 20; // Maximum width for the text
    const lineHeight = 20; // Line height

    ctx.fillStyle = 'white';
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'left';

    const instructionsList = [
        "How to play:",
        "",
        "- Click/tap and hold to shoot a projectile",
        // "3. Make sure to also handle the other thing.",
        // "4. Be aware of the limits and try to achieve the goals."
    ];
    wrapTextList(ctx, instructionsList, 10, instructionsY, maxWidth, lineHeight);
}
// function drawInstructions() {
//     let instructionsY = howToPlayButton.y + howToPlayButton.height + 20; // Position below the "How to Play" button
//     ctx.fillStyle = 'white';
//     ctx.font = '10px "Press Start 2P"';
//     ctx.textAlign = 'left';
//     ctx.fillText('How to play:', 10, instructionsY);
//     ctx.fillText('- Click/tap and hold to shoot a projectile', 10, instructionsY + 20);
//     ctx.fillText('- Red balloons require a fully charged shot to burst', 10, instructionsY + 40);
//     // Add more instructions as needed
// }

function checkPlayButtonPress(x, y) {
    if (x >= playButton.x && x <= playButton.x + playButton.width &&
        y >= playButton.y && y <= playButton.y + playButton.height) {
        startGame();
    }
}
canvas.addEventListener('click', function(event) {
    if (gameStarted) return; // Ignore clicks if the game has already started

    const rect = canvas.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;

    checkPlayButtonPress(clickX, clickY);
});
canvas.addEventListener('touchend', function(event) {
    if (gameStarted) return; // Ignore touches if the game has already started

    event.preventDefault(); // Prevents default scrolling behavior on touch devices

    const touch = event.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;

    checkPlayButtonPress(touchX, touchY);
});


        const projectiles = [];
        const slingshot = { x: canvas.width / 2, y: canvas.height - 20 };
        const speed = 5;
        const projectileRadius = 5;

        let balloons = [];
        const balloonRadius = 25;
        const gravity = 1;

        let isMouseDown = false;
        let mouseDownTime = 0;

        const maxSpeed = 30;
        const powerBar = { width: 10, height: 60, x: slingshot.x - 30, y: slingshot.y - 100 };
        const minChargeTime = 800; // Shorter time represents less power

        const minPowerThreshold = 0.5; // Minimum power required to shoot

        // let startTime = Date.now();
        const redBalloonGravity = 0.55; // Slower falling speed for red balloons
        const redBalloonSpawnInterval = 2000; // Less frequent spawn for red balloons

        let balloonSpawnInterval = 800; // Initial spawn interval in milliseconds

        let score = 0;

        let isDoubleShotEnabled = false;
        const doubleShotUpgradeCost = 500;
        let isTripleShotEnabled = false; // New variable for triple shot
        const tripleShotUpgradeCost = 2000; // Cost for triple shot
        let isMetalShotEnabled = false; // New variable for metal shot
        const metalShotUpgradeCost = 2000; // Cost for metal shot

        let elapsedTime = 0;

        let upgradeButton = { x: 10, y: canvas.height - 50, width: 100, height: 40, text: 'Upgrade' };

        let gameOver = false;

        // let playAgainButton = { x: canvas.width / 2.5 - 60, y: canvas.height / 2 + 30, width: 170, height: 40, text: 'Refresh to restart' };

        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;

        // Somewhere in your global variables
        let powerUpActive = false;
        let powerUpEndTime = 0;
        let maxPower = maxSpeed;  // Assuming maxSpeed is the full power for a shot

        let isTouching = false;

        let lastFrameTime = Date.now();

        let lastSpawnTime = 0;

        function getRandomBalloonColor() {
    const colors = ['red', 'blue', 'green', 'yellow']; // Add more colors as needed
    return colors[Math.floor(Math.random() * colors.length)];
}

function updateMenuBalloons() {
    // Randomly decide whether to spawn a balloon
    if (Math.random() < 0.1) { // Adjust this probability as needed
        if (menuBalloons.length < 20) { // Ensure there's a max number of balloons
            menuBalloons.push(createMenuBalloon());
        }
    }

    // Update balloon positions
    menuBalloons.forEach((balloon, index) => {
        balloon.y += balloon.vy;

        // Remove the balloon when it's completely off-screen
        if (balloon.y > canvas.height + balloonRadius) {
            menuBalloons.splice(index, 1);
        }
    });
}

function createMenuBalloon() {
    const x = Math.random() * canvas.width;
    const vy = gravity - 0.8 + Math.random() * 0.5; // Adjust the random factor as needed

    return {
        x: x,
        y: -balloonRadius,
        vy: vy,
        color: getRandomBalloonColor(),
        isPopping: false
    };
}


let playButton = {
    x: canvas.width / 2 - 50, // Center the button on the canvas
    y: canvas.height / 2 - 25,
    width: 100,
    height: 50,
    radius: 10
};
let howToPlayButton = {
    x: canvas.width / 2 - 100,
    y: playButton.y + 70, // Positioned below the "PLAY" button
    width: 200,
    height: 50,
    radius: 10
};
let backButton = {
    x: canvas.width / 2 - 50,
    y: canvas.height - 100,
    width: 100,
    height: 50,
    radius: 10
};

function drawButton(button, text) {
    // Reset shadow for button
    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 4;

    // Gradient for button
    let gradient = ctx.createLinearGradient(button.x, button.y, button.x, button.y + button.height);
    gradient.addColorStop(0, '#28a745'); // Light green
    gradient.addColorStop(1, '#155d27'); // Dark green

    // Draw button
    ctx.beginPath();
    ctx.moveTo(button.x + button.radius, button.y);
    ctx.arcTo(button.x + button.width, button.y, button.x + button.width, button.y + button.height, button.radius);
    ctx.arcTo(button.x + button.width, button.y + button.height, button.x, button.y + button.height, button.radius);
    ctx.arcTo(button.x, button.y + button.height, button.x, button.y, button.radius);
    ctx.arcTo(button.x, button.y, button.x + button.width, button.y, button.radius);
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();

    // Text on button
    ctx.fillStyle = 'white';
    ctx.font = '16px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, button.x + button.width / 2, button.y + button.height / 2);

    // Reset shadow for other elements
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
}


let showingInstructions = false;

canvas.addEventListener('click', function(event) {
    if (gameStarted) return; // Ignore clicks if the game has already started

    const rect = canvas.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;

    console.log("Clicked at:", clickX, clickY);

    if (!showingInstructions) {
        console.log("Clicked at:", clickX, clickY);
        console.log("How to Play Button bounds:", howToPlayButton.x, howToPlayButton.y, howToPlayButton.x + howToPlayButton.width, howToPlayButton.y + howToPlayButton.height);

        if (isInsideButton(clickX, clickY, howToPlayButton)) {
            console.log("How to Play clicked");
            showingInstructions = true;
            displayHowToPlayInstructions();
        }
    } else {

        console.log("Instructions screen"); // For debugging
        if (isInsideButton(clickX, clickY, backButton)) {
            console.log("Back clicked"); // For debugging
            showingInstructions = false;
            drawMainMenu();
        }
    }
});

function isInsideButton(x, y, button) {
    return x > button.x && x < button.x + button.width && y > button.y && y < button.y + button.height;
}


function drawDebugRect(button) {
    ctx.strokeStyle = 'red'; // Temporary border color for debugging
    ctx.strokeRect(button.x, button.y, button.width, button.height);
}

function displayHowToPlayInstructions() {
    // Clear canvas and draw instructions
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'white';
    ctx.font = '16px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('How to Play', canvas.width / 2, 50);
    ctx.fillText('Instructions go here...', canvas.width / 2, 100);
    // Add more text or images as needed to explain the game

    drawButton(backButton, 'Back');
}



        canvas.addEventListener('touchstart', function (event) {
            event.preventDefault();
            const touch = event.touches[0] || event.changedTouches[0]; // Ensure we're getting the touch
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
            touchStartTime = new Date().getTime();

            // console.log("Touch Start:", touchStartX, touchStartY); // Log the touch start coordinates

            isTouching = true;
            requestAnimationFrame(updatePowerBar);
        }, { passive: false });


        canvas.addEventListener('touchmove', function (event) {
            const touch = event.touches[0] || event.changedTouches[0];
            touchStartX = touch.clientX - canvas.getBoundingClientRect().left;
            touchStartY = touch.clientY - canvas.getBoundingClientRect().top;

            // console.log("Touch Move:", touchStartX, touchStartY); // Log touch move coordinates
        }, { passive: false });


        canvas.addEventListener('touchend', function (event) {
            event.preventDefault();
            const touchDuration = new Date().getTime() - touchStartTime;
            const power = Math.min(touchDuration / minChargeTime, 1);

            // console.log("Touch End - Duration:", touchDuration, "Coords:", touchStartX, touchStartY); // Log touch end details

            // IF YOU UNCOMMENT THIS IT WILL SHOOT TWO PROJECTILES
            // if (power >= minPowerThreshold) {
            //     createProjectile(touchStartX, touchStartY, touchDuration);
            // }
            // If power-up is active, fire immediately on tap, else calculate power
            if (powerUpActive) {
                createProjectile(touchStartX, touchStartY, minChargeTime); // Full power shot
            } else {
                const power = Math.min(touchDuration / minChargeTime, 1);
                if (power >= minPowerThreshold) {
                    createProjectile(touchStartX, touchStartY, touchDuration);
                }
            }

            isTouching = false;
        }, { passive: false });

        canvas.addEventListener('touchend', function (event) {
            const touch = event.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            // Assuming you have a function to handle button clicks
            handleUpgradeClick(x, y);
            handlePowerUpButtonClick(x, y);
            handleButtonClick(x, y)
        });

        function drawUpgradeButton() {
            if (!isTripleShotEnabled && score >= tripleShotUpgradeCost) {
                const buttonWidth = 103;  // Button width
                const buttonHeight = 30; // Button height
                const margin = 10;
                const buttonX = margin;
                const buttonY = canvas.height - buttonHeight - margin;

                // Draw button background
                ctx.fillStyle = '#00FF00'; // Bright green
                ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

                // Add pixelated border
                ctx.strokeStyle = '#008000'; // Darker green for border
                ctx.lineWidth = 3;
                ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

                // Draw button text
                ctx.font = '12px "Press Start 2P"'; // Pixelated font
                ctx.fillStyle = '#000000'; // Black for text
                ctx.fillText('Upgrade', buttonX + 10, buttonY + 20); // Adjust text position
            } else if (!isDoubleShotEnabled && score >= doubleShotUpgradeCost) {
                const buttonWidth = 103;  // Button width
                const buttonHeight = 30; // Button height
                const margin = 10;
                const buttonX = margin;
                const buttonY = canvas.height - buttonHeight - margin;

                // Draw button background
                ctx.fillStyle = '#00FF00'; // Bright green
                ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

                // Add pixelated border
                ctx.strokeStyle = '#008000'; // Darker green for border
                ctx.lineWidth = 3;
                ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

                // Draw button text
                ctx.font = '12px "Press Start 2P"'; // Pixelated font
                ctx.fillStyle = '#000000'; // Black for text
                ctx.fillText('Upgrade', buttonX + 10, buttonY + 20); // Adjust text position
            }
        }

        function isInsideButton(pos, btn) {
            return pos.x > btn.x && pos.x < btn.x + btn.width && pos.y > btn.y && pos.y < btn.y + btn.height;
        }

        function handleUpgradeClick(x, y) {
            const pos = { x, y };
            if (isInsideButton(pos, upgradeButton)) {
                if (!isDoubleShotEnabled && score >= doubleShotUpgradeCost) {
                    purchaseUpgrade('double');
                } else if (!isTripleShotEnabled && score >= tripleShotUpgradeCost) {
                    purchaseUpgrade('triple');
                }
            }
        }

        canvas.addEventListener('click', function (event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handleUpgradeClick(x, y);
        });

        function updateSpawnInterval() {
            const timeElapsed = Date.now() - startTime;
            if (timeElapsed > 180000) { // After 120 seconds
                balloonSpawnInterval = 300; // Update interval to 100
                console.log(balloonSpawnInterval);
                } else if (timeElapsed > 120000) { // After 0.9 seconds
                     balloonSpawnInterval = 400; // Update interval to 700
                console.log(balloonSpawnInterval);
            } else if (timeElapsed > 30000) { // After 0.9 seconds
                balloonSpawnInterval = 600; // Update interval to 700
                console.log(balloonSpawnInterval);
            }
        }


        canvas.addEventListener('mouseup', function (event) {
            if (isMouseDown) {
                const currentTime = new Date().getTime();
                const timeHeld = currentTime - mouseDownTime;
                const power = Math.round((Math.min(timeHeld / minChargeTime, 1)) * 100) / 100;

                if (power >= minPowerThreshold) {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    createProjectile(x, y, timeHeld);
                }

                isMouseDown = false;
            }
        });

        function purchaseUpgrade(type) {
            if (type === 'double' && score >= doubleShotUpgradeCost && !isDoubleShotEnabled) {
                score -= doubleShotUpgradeCost;
                isDoubleShotEnabled = true;
            } else if (type === 'triple' && score >= tripleShotUpgradeCost && !isTripleShotEnabled) {
                score -= tripleShotUpgradeCost;
                isTripleShotEnabled = true;
            }
        }

        function createProjectile(x, y, timeHeld) {
            const angle = Math.atan2(y - slingshot.y, x - slingshot.x);
            let power = Math.min(timeHeld / minChargeTime, 1);

            if (powerUpActive) {
                power = 1; // Full power if power-up is active
            }

            const projectileSpeed = power * maxSpeed;

            // Create projectiles based on upgrades
            projectiles.push({
                x: slingshot.x,
                y: slingshot.y,
                vx: Math.cos(angle) * projectileSpeed,
                vy: Math.sin(angle) * projectileSpeed,
                power: power
            });

            if (isDoubleShotEnabled || isTripleShotEnabled) {
                projectiles.push({
                    x: slingshot.x + 20,
                    y: slingshot.y,
                    vx: Math.cos(angle) * projectileSpeed,
                    vy: Math.sin(angle) * projectileSpeed,
                    power: power
                });
            }

            if (isTripleShotEnabled) {
                projectiles.push({
                    x: slingshot.x - 20,
                    y: slingshot.y,
                    vx: Math.cos(angle) * projectileSpeed,
                    vy: Math.sin(angle) * projectileSpeed,
                    power: power
                });
            }
        }

        function drawPowerBar(power) {
                // Draw border
    ctx.fillStyle = 'black';
    ctx.fillRect(powerBar.x - 3, powerBar.y - 3, powerBar.width + 2, powerBar.height + 2); // 1px border


            ctx.fillStyle = 'grey';
            ctx.fillRect(powerBar.x, powerBar.y, powerBar.width, powerBar.height);

                // Draw the threshold indicator (e.g., a line at 50%)
    // ctx.strokeStyle = 'red'; // Red line for threshold
    // ctx.beginPath();
    // ctx.moveTo(powerBar.x, powerBar.y + powerBar.height / 2);
    // ctx.lineTo(powerBar.x + powerBar.width, powerBar.y + powerBar.height / 2);
    // ctx.stroke();

    // Draw the actual power bar
    // Use different colors above and below the threshold
    const powerHeight = powerBar.height * power;
    const thresholdHeight = powerBar.height / 2;
    ctx.fillStyle = power >= minPowerThreshold -0.13 ? 'green' : 'darkred';
    ctx.fillRect(powerBar.x, powerBar.y + powerBar.height - powerHeight, powerBar.width, powerHeight);
}

        canvas.addEventListener('mousedown', function (event) {
            isMouseDown = true;
            mouseDownTime = new Date().getTime();
            requestAnimationFrame(updatePowerBar);
        });

        function updatePowerBar() {
            if ((isMouseDown || isTouching) && !powerUpActive && gameStarted && !gameOver) { // Add check for powerUpActive
                const currentTime = new Date().getTime();
                // Use touchStartTime for touch events and mouseDownTime for mouse events
                const startTime = isTouching ? touchStartTime : mouseDownTime;
                const timeHeld = Math.min((currentTime - startTime) / 1000, 1); // Max 1 second charge
                drawPowerBar(timeHeld);
                requestAnimationFrame(updatePowerBar);
            }
        }



        let projectileSprite = new Image();
        projectileSprite.src = 'grey.png'; // Replace with the path to your projectile sprite

        function drawProjectile(projectile) {
            ctx.drawImage(projectileSprite, projectile.x - projectileRadius, projectile.y - projectileRadius, projectileRadius * 2, projectileRadius * 2);
        }

        // Load sprite sheets
        let blueBalloonPopSprite = new Image();
        blueBalloonPopSprite.src = 'bluepop.png'; // Path to blue balloon pop sprite sheet

        let redBalloonPopSprite = new Image();
        redBalloonPopSprite.src = 'redpop.png'; // Path to red balloon pop sprite sheet

        let greenBalloonPopSprite = new Image();
        greenBalloonPopSprite.src = 'greenpop.png'; // Path to green balloon pop sprite sheet

        let yellowBalloonPopSprite = new Image(); // Add this line
        yellowBalloonPopSprite.src = 'yellowpop.png'; // Path to yellow balloon pop sprite sheet


        function spawnBalloon() {
            const currentTime = Date.now();
            const timeElapsed = currentTime - startTime;

            const x = Math.random() * canvas.width;
            let balloon;
            let shouldSpawnBalloon = true;

            const isGreenBalloon = timeElapsed > 60000 && Math.random() < 0.3; // Less rare green balloon
            const isRedBalloon = timeElapsed > 30000 && Math.random() < 0.7; // Common red balloon
            const isYellowBalloon = timeElapsed > 1000 && Math.random() < 0.15; // Very rare yellow balloon


            if (isYellowBalloon) {
                // Yellow balloons introduced after 100 seconds, very fast
                balloon = { x: x, y: -balloonRadius, vy: gravity * 4, color: 'yellow' };
            } else if (isGreenBalloon) {
                // Green balloons introduced after 60 seconds, twice as fast
                balloon = { x: x, y: -balloonRadius, vy: gravity * 2, color: 'green' };
            } else if (isRedBalloon) {
                // Red balloons introduced after 30 seconds
                balloon = { x: x, y: -balloonRadius, vy: redBalloonGravity, color: 'red' };
            } else {
                // Default blue balloons
                balloon = { x: x, y: -balloonRadius, vy: gravity, color: 'blue' };
            }

            // Make sure to initialize balloon popping state and sprite sheet
            balloon.isPopping = false;
            balloon.popFrame = 0;
            balloon.spriteSheet = getBalloonSpriteSheet(balloon.color);

            // Decide if the balloon should be spawned based on its rarity
            if (isYellowBalloon) {
                shouldSpawnBalloon = Math.random() < 0.04; // Adjust for the desired rarity of yellow balloons
            }

            // Add the balloon to the array if it should be spawned
            if (shouldSpawnBalloon) {
                balloons.push(balloon);
            }
        }


        function getBalloonSpriteSheet(color) {
            switch (color) {
                case 'blue': return blueBalloonPopSprite;
                case 'red': return redBalloonPopSprite;
                case 'green': return greenBalloonPopSprite;
                case 'yellow': return yellowBalloonPopSprite; // Add this line
                default: return null;
            }
        }

        let blueBalloonSprite = new Image();
        blueBalloonSprite.src = 'blue.png'; // Replace with the path to your sprite image

        let redBalloonSprite = new Image();
        redBalloonSprite.src = 'red.png'; // Replace with the path to your red balloon sprite

        let greenBalloonSprite = new Image();
        greenBalloonSprite.src = 'green.png'; // Replace with the path to your green balloon sprite

        let yellowBalloonSprite = new Image(); // Add this line
        yellowBalloonSprite.src = 'yellow.png'; // Path to your yellow balloon sprite


        function drawBalloon(balloon) {
            if (balloon.isPopping) {
                const frameSize = 32; // Adjust according to your sprite sheet
                const cols = 2; // Number of columns in your sprite sheet
                const animationSpeed = 1; // Number of frames to wait before changing the sprite frame
                const totalFrames = 6; // Total number of frames in your sprite sheet

                const row = Math.floor(balloon.popFrame / cols);
                const col = balloon.popFrame % cols;

                ctx.drawImage(balloon.spriteSheet, col * frameSize, row * frameSize, frameSize, frameSize, balloon.x - balloonRadius, balloon.y - balloonRadius, balloonRadius * 2, balloonRadius * 2);

                if (balloon.frameCounter === undefined) {
                    balloon.frameCounter = 0;
                }

                balloon.frameCounter++;

                if (balloon.frameCounter >= animationSpeed) {
                    balloon.popFrame++;
                    balloon.frameCounter = 0; // Reset the counter
                }

                if (balloon.popFrame >= totalFrames) {
                    balloon.remove = true; // Mark for removal after animation
                }
            } else {

                switch (balloon.color) {
                    case 'blue':
                        ctx.drawImage(blueBalloonSprite, balloon.x - balloonRadius, balloon.y - balloonRadius, balloonRadius * 2, balloonRadius * 2);
                        break;
                    case 'red':
                        ctx.drawImage(redBalloonSprite, balloon.x - balloonRadius, balloon.y - balloonRadius, balloonRadius * 2, balloonRadius * 2);
                        break;
                    case 'green':
                        ctx.drawImage(greenBalloonSprite, balloon.x - balloonRadius, balloon.y - balloonRadius, balloonRadius * 2, balloonRadius * 2);
                        break;
                    case 'yellow': // Add this case
                        ctx.drawImage(yellowBalloonSprite, balloon.x - balloonRadius, balloon.y - balloonRadius, balloonRadius * 2, balloonRadius * 2);
                        break;
                    default:
                        // Default drawing for other balloons
                        ctx.beginPath();
                        ctx.arc(balloon.x, balloon.y, balloonRadius, 0, Math.PI * 2);
                        ctx.fillStyle = balloon.color;
                        ctx.fill();
                        ctx.closePath();
                }
            }
        }

        function drawScore() {
            ctx.font = '12px "Press Start 2P"'; // Set the font size and family
            ctx.fillStyle = 'white'; // Set the text color
            ctx.fillText('Points: ' + score, 20, 30); // Draw the score text
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw the static projectile at the slingshot
            drawStaticProjectileAtSlingshot();
            projectiles.forEach(drawProjectile);
            balloons.forEach(drawBalloon);
            drawScore();
            drawTimer();
            drawUpgradeButton();
            drawPowerUpButton();
        }

        function drawStaticProjectileAtSlingshot() {
            if (projectileSprite.complete && projectileSprite.naturalHeight !== 0) {
                // Assuming you have a slingshot object with x and y properties
                const projectileRadius = 5; // Use the same radius as in drawProjectile
                const offsetX = projectileRadius; // To center the image at the slingshot
                const offsetY = projectileRadius; // To center the image at the slingshot

                ctx.drawImage(projectileSprite, slingshot.x - offsetX, slingshot.y - offsetY, projectileRadius * 2, projectileRadius * 2);
            }
        }



        function handlePowerUpButtonClick(x, y) {
            const buttonWidth = 100;
            const buttonHeight = 50;
            const margin = 10;
            const buttonX = canvas.width - buttonWidth - margin;
            const buttonY = canvas.height - buttonHeight - margin;

            // Check if the click/tap is within the button's area
            if (x >= buttonX && x <= buttonX + buttonWidth && y >= buttonY && y <= buttonY + buttonHeight && hasStoredPowerUp) {
                activatePowerUp();
                hasStoredPowerUp = false; // Reset the stored power-up
            }
        }

        let popSoundUrls = ['pop2.mp3']; // Add more sound file URLs as needed
        let popSounds = popSoundUrls.map(url => new Audio(url));

        let hasStoredPowerUp = false;

        function detectCollisions() {
            projectiles.forEach((projectile, pIndex) => {
                balloons.forEach((balloon, bIndex) => {
                    const dist = Math.sqrt((projectile.x - balloon.x) ** 2 + (projectile.y - balloon.y) ** 2);
                    if (dist < balloonRadius + projectileRadius && !balloon.isPopping) {
                        // Check the color of the balloon and apply power-up if it's yellow
                        if (balloon.color === 'yellow') {
                            hasStoredPowerUp = true;
                            // activatePowerUp();
                        }
                        if (balloon.color !== 'red' || projectile.power === 1) {

                            // Start popping animation instead of removing the balloon
                            balloon.isPopping = true;

                            // Create and play a new Audio instance for the pop sound
                            let randomSoundIndex = Math.floor(Math.random() * popSounds.length);
                            let sound = new Audio(popSounds[randomSoundIndex].src);
                            sound.play();

                            score += (balloon.color === 'blue') ? 10 : 20;
                            projectiles.splice(pIndex, 1); // Remove the projectile
                        }
                    }
                });
            });
        }

        function drawPowerUpButton() {
            if (hasStoredPowerUp) {
                const buttonWidth = 113;  // Smaller width
                const buttonHeight = 30; // Smaller height
                const margin = 10;
                const buttonX = canvas.width - buttonWidth - margin;
                const buttonY = canvas.height - buttonHeight - margin;

                // Draw button background
                ctx.fillStyle = '#FFFF00'; // Bright yellow
                ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

                // Add pixelated border
                ctx.strokeStyle = '#FFD700'; // Gold for border
                ctx.lineWidth = 3;
                ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

                // Draw button text
                ctx.font = '12px "Press Start 2P"'; // Smaller font size
                ctx.fillStyle = '#000000'; // Black for text
                const textX = buttonX + 10;
                const textY = buttonY + 20; // Adjust y position for smaller button
                ctx.fillText('Power-Up', textX, textY);
            }
        }


        function activatePowerUp() {
            powerUpActive = true;
            powerUpEndTime = Date.now() + 10000; // 10 seconds from now
        }


        function updateTimer() {
            elapsedTime = Date.now() - startTime;
        }

        function drawTimer() {
            const seconds = Math.floor(elapsedTime / 1000);
            ctx.font = '12px "Press Start 2P"'; // Use Press Start 2P font
            ctx.fillStyle = 'white';
            ctx.fillText('Time: ' + seconds + 's', canvas.width - 125, 30);
        }


        canvas.addEventListener('click', function (event) {
            if (powerUpActive) {
                // Fire a full power shot
                fireFullPowerShot(event);
            } else {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                createProjectile(x, y);
            }
        });

        // Function to create a full power shot
        function fireFullPowerShot(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            createProjectile(x, y, minChargeTime); // Fire with max power regardless of charge time
        }

        function gameLoop() {
            if (!gameStarted) return; // Prevent the game loop from running if the game hasn't started
            // Check if the game is not over
            if (!gameOver) {
                const currentFrameTime = Date.now();
                const deltaTime = ((currentFrameTime - lastFrameTime) / 1000) * 60;
                lastFrameTime = currentFrameTime;
                elapsedTime = currentFrameTime - startTime;

                // Update game elements
                updateProjectiles(deltaTime);
                updateBalloons(deltaTime);
                detectCollisions();
                updateTimer();
                updateSpawnInterval();

                // Draw game elements
                draw();
                spawnBalloonIfNeeded();

                // Check if the power-up should still be active
                if (powerUpActive && Date.now() > powerUpEndTime) {
                    powerUpActive = false;
                }
            }

            // Request the next frame
            requestAnimationFrame(gameLoop);

            // Check and display game over screen
            if (gameOver) {
                displayGameOver();
            }
        }

        let skyTexture = new Image();

        function startGame() {
    gameStarted = true;
    startTime = Date.now(); // Initialize startTime here
    gameLoop(); // Start the game loop
}


skyTexture.onload = function() {
    // Image loaded
    console.log("Sky texture loaded.");
};        skyTexture.onerror = function () {
            console.error('Failed to load the sky texture.');
        };
        skyTexture.src = 'cloud1.png'; // Make sure this is the correct path

        // If the image is cached, it might be already loaded at this point, so check for that
        if (skyTexture.complete) {
            startGame();
        }

        function drawBackground(ctx, canvas, offset) {
            const pattern = ctx.createPattern(skyTexture, 'repeat');
            ctx.fillStyle = pattern;

            ctx.save();
            ctx.translate(-offset, 0);
            ctx.fillRect(0, 0, canvas.width, canvas.height); // Fill the entire canvas
            ctx.restore();
        }

        function spawnBalloonIfNeeded() {
            if (Date.now() - lastSpawnTime > balloonSpawnInterval) {
                spawnBalloon();
                lastSpawnTime = Date.now();
            }
        }

        function updateProjectiles(deltaTime) {
            projectiles.forEach(p => {
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
            });
        }

        function updateBalloons(deltaTime) {
            balloons.forEach((balloon, index) => {
                if (balloon.remove) {
                    balloons.splice(index, 1);
                } else {
                    balloon.y += balloon.vy * deltaTime;
                    if (balloon.y > canvas.height) {
                        gameOver = true;
                    }
                }
            });
        }


        function drawPlayAgainButton() {
    // Gradient for button
    let gradient = ctx.createLinearGradient(playAgainButton.x, playAgainButton.y, playAgainButton.x, playAgainButton.y + playAgainButton.height);
    gradient.addColorStop(0, '#28a745'); // Light green for top of button
    gradient.addColorStop(1, '#155d27'); // Dark green for bottom of button

    // Draw rounded button background
    ctx.beginPath();
    ctx.moveTo(playAgainButton.x + playAgainButton.radius, playAgainButton.y);
    ctx.arcTo(playAgainButton.x + playAgainButton.width, playAgainButton.y, playAgainButton.x + playAgainButton.width, playAgainButton.y + playAgainButton.height, playAgainButton.radius);
    ctx.arcTo(playAgainButton.x + playAgainButton.width, playAgainButton.y + playAgainButton.height, playAgainButton.x, playAgainButton.y + playAgainButton.height, playAgainButton.radius);
    ctx.arcTo(playAgainButton.x, playAgainButton.y + playAgainButton.height, playAgainButton.x, playAgainButton.y, playAgainButton.radius);
    ctx.arcTo(playAgainButton.x, playAgainButton.y, playAgainButton.x + playAgainButton.width, playAgainButton.y, playAgainButton.radius);
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();

    // Add shadow for 3D effect
    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 4;
    ctx.fill();

    // Reset shadow for other elements
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // Button Text
    ctx.fillStyle = 'white'; // Text color
    ctx.font = '16px "Press Start 2P"'; // Adjust font size as needed
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(playAgainButton.text, playAgainButton.x + playAgainButton.width / 2, playAgainButton.y + playAgainButton.height / 2);

    // After drawing the "PLAY" button
ctx.textAlign = 'left';
}


        function displayGameOver() {
            ctx.font = '36px "Press Start 2P"'; // Use Press Start 2P font
            ctx.fillStyle = 'red';
            ctx.fillText('Game Over', canvas.width / 2.9 - 100, canvas.height / 2); // You might need to adjust the position
            drawPlayAgainButton();
        }


        function restartGame() {
    // Reset game state variables
    gameOver = false;
    score = 0;
    balloons = [];
    // projectiles = [];
    startTime = Date.now();
    showingInstructions = false; // If you have this flag for showing instructions
    let elapsedTime = 0;

    // Reset any other necessary variables
    // For example, if you have a variable for elapsed game time, reset it here

    // Begin the game loop again
    gameLoop();
}


        canvas.addEventListener('click', function(event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    handleButtonClick(x, y);
});


        function handleButtonClick(x, y) {
    if (gameOver && x > playAgainButton.x && x < playAgainButton.x + playAgainButton.width &&
        y > playAgainButton.y && y < playAgainButton.y + playAgainButton.height) {
        restartGame();
    }
}

let playAgainButton = {
    x: canvas.width / 2 - 95, // Adjust as needed
    y: canvas.height / 2 + 30, // Adjust as needed
    width: 180, // Adjust as needed
    height: 50, // Adjust as needed
    radius: 10, // Adjust for roundness
    text: 'Play Again'
};


// function drawPlayAgainButton() {
//     ctx.fillStyle = 'blue';
//     ctx.fillRect(playAgainButton.x, playAgainButton.y, playAgainButton.width, playAgainButton.height);

//     ctx.font = '8px "Press Start 2P"';
//     ctx.fillStyle = 'white';
//     ctx.textAlign = 'center';
//     ctx.textBaseline = 'middle';
//     ctx.fillText(playAgainButton.text, playAgainButton.x + playAgainButton.width / 2, playAgainButton.y + playAgainButton.height / 2);
// }


        canvas.addEventListener('click', function (event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handleButtonClick(x, y);
            handlePowerUpButtonClick(x, y);
        });

        drawMainMenu();

        // gameLoop();

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered! Scope:', registration.scope);
                    })
                    .catch(err => {
                        console.log('Service Worker registration failed:', err);
                    });
            });
        }

        let deferredPrompt;

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            // Update UI to show an install button
            btnInstall.style.display = 'block';
        });

        btnInstall.addEventListener('click', () => {
            // Hide the install button
            btnInstall.style.display = 'none';
            // Show the install prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('User accepted the install prompt');
                } else {
                    console.log('User dismissed the install prompt');
                }
            });
        });

    </script>
</body>

</html>
